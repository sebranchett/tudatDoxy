<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tudat: tudat::coordinate_conversions Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tudat
   </div>
   <div id="projectbrief">TU Delft astrodynamics toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d6d/namespacetudat.html">tudat</a></li><li class="navelem"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html">coordinate_conversions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tudat::coordinate_conversions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae79813c5dfc8119739a637cabd5f88ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88ea">CartesianCoordinateIndices</a> { <br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88eaab772b62b1d6d4f8975883bafa8512f0b">xCartesianCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88eaab21d79431b6645ae5491b9bea1660fc9">yCartesianCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88eaaf51c9c83a5b2d22739edae60c4cd011f">zCartesianCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88eaa49dd89be31f1a72935f2499dcb6c3866">xDotCartesianCoordinateIndex</a>, 
<br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88eaa819a1ec07aacfd6aa910bea30262e537">yDotCartesianCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88eaae89d0b57911de2749977df4c1647d89c">zDotCartesianCoordinateIndex</a>
<br />
 }<tr class="memdesc:ae79813c5dfc8119739a637cabd5f88ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cartesian coordinate indices.  <a href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88ea">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae79813c5dfc8119739a637cabd5f88ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fa82bea6358f0d3e26482aa11a50ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50ee">CylindricalCoordinateIndices</a> { <br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50eea7d2bfec7fb93d117387abf3a7b23998c">rCylindricalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50eea3eb72df42b4c40a607835437481443b3">thetaCylindricalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50eea00c10bd07d1c40247ab6c8478c3972e1">zCylindricalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50eea5deb8fbd197d973ffcc46cb42b03853b">rDotCylindricalCoordinateIndex</a>, 
<br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50eeada801aade4f6b827507509529a5af6ac">vThetaCylindricalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50eeaba4feec5b2ef495fcf10efd77a0b8c15">zDotCylindricalCoordinateIndex</a>
<br />
 }<tr class="memdesc:af7fa82bea6358f0d3e26482aa11a50ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cylindrical coordinate indices.  <a href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50ee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af7fa82bea6358f0d3e26482aa11a50ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e504281e15b897419420663300c106e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106e">PositionElementTypes</a> { <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106ea641f0af1ef657ae42b959ee6f988a6a3">cartesian_position</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106ea5f31201b9463b4bbd079378db4181828">spherical_position</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106ea747df972a51b4f58fd49792836e75a50">geodetic_position</a>
 }<tr class="memdesc:a4e504281e15b897419420663300c106e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum defining available types of position representations.  <a href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4e504281e15b897419420663300c106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6d2084cdf9790a922a6db2e8b5840c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840c">SphericalCoordinateIndices</a> { <br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840ca7074a15eee73e60af3b82279fde8d9b0">radiusSphericalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840cab2c0704d1a58f152cb64a694f3a68eac">azimuthSphericalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840ca4ea66f82a71fd66d95c2d77e4e20590d">elevationSphericalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840ca4595d181bc65b1d236332e266b7a9c2e">radialVelocitySphericalCoordinateIndex</a>, 
<br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840ca57de322cd1fc1a215f38b1efa7ce00a0">azimuthVelocitySphericalCoordinateIndex</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840ca7f7603fe6b2f1ae6bb690a291a882331">elevationVelocitySphericalCoordinateIndex</a>
<br />
 }<tr class="memdesc:abb6d2084cdf9790a922a6db2e8b5840c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical coordinate indices.  <a href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:abb6d2084cdf9790a922a6db2e8b5840c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff78ce49131008b3ee13015cc7114586"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586">StateElementTypes</a> { <br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586a196031f20e3a89aeba236c93bd6847bd">cartesian_state</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586a42ace40c5a97139d9ca61aeb9af16e17">keplerian_state</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586ad168417d7d7980a7eae4e05c13eb5789">modified_equinoctial_state</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586a3afce2f3d6691df696c5e82726aea2da">unified_state_model_quaternions_state</a>, 
<br />
&#160;&#160;<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586a20326a506d57dc61361dfb68b78e8557">unified_state_model_modified_rodrigues_parameters_state</a>, 
<a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586ad9036d766c347a864ebe4598a3bf38f7">unified_state_model_exponential_map_state</a>
<br />
 }<tr class="memdesc:aff78ce49131008b3ee13015cc7114586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum defining available types of position representations.  <a href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aff78ce49131008b3ee13015cc7114586"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7a6a98585e107eee2685198f9e90e9bc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a7a6a98585e107eee2685198f9e90e9bc">calculateAltitudeOverOblateSpheroid</a> (const Eigen::Vector3d cartesianState, const double zInterceptOffset, const double interceptToSurfaceDistance)</td></tr>
<tr class="memdesc:a7a6a98585e107eee2685198f9e90e9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the altitude over an oblate spheroid of a position vector from auxiliary variables.  <a href="#a7a6a98585e107eee2685198f9e90e9bc">More...</a><br /></td></tr>
<tr class="separator:a7a6a98585e107eee2685198f9e90e9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01504cc9d29bc382d1289119fff5fc49"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a01504cc9d29bc382d1289119fff5fc49">calculateAltitudeOverOblateSpheroid</a> (const Eigen::Vector3d cartesianState, const double equatorialRadius, const double flattening, const double tolerance)</td></tr>
<tr class="memdesc:a01504cc9d29bc382d1289119fff5fc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the altitude over an oblate spheroid of a position vector.  <a href="#a01504cc9d29bc382d1289119fff5fc49">More...</a><br /></td></tr>
<tr class="separator:a01504cc9d29bc382d1289119fff5fc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c0028e09b2dbefab4d99d6441075b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a04c0028e09b2dbefab4d99d6441075b7">calculateEllipticity</a> (const double flattening)</td></tr>
<tr class="memdesc:a04c0028e09b2dbefab4d99d6441075b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the ellipticity of an ellipsoid.  <a href="#a04c0028e09b2dbefab4d99d6441075b7">More...</a><br /></td></tr>
<tr class="separator:a04c0028e09b2dbefab4d99d6441075b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf522731643441bb47479a2ea015385"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aadf522731643441bb47479a2ea015385">calculateGeodeticCoordinatesAuxiliaryQuantities</a> (const Eigen::Vector3d cartesianState, const double equatorialRadius, const double ellipticity, const double tolerance)</td></tr>
<tr class="memdesc:aadf522731643441bb47479a2ea015385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate auxiliary quantities for geodetic coordinate conversions.  <a href="#aadf522731643441bb47479a2ea015385">More...</a><br /></td></tr>
<tr class="separator:aadf522731643441bb47479a2ea015385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4171db69638b9ed13b07e6e1528ddec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae4171db69638b9ed13b07e6e1528ddec">calculateGeodeticLatitude</a> (const Eigen::Vector3d cartesianState, const double zInterceptOffset)</td></tr>
<tr class="memdesc:ae4171db69638b9ed13b07e6e1528ddec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the geodetic latitude from Cartesian position and offset of z-intercept.  <a href="#ae4171db69638b9ed13b07e6e1528ddec">More...</a><br /></td></tr>
<tr class="separator:ae4171db69638b9ed13b07e6e1528ddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74413a9f6b657d2673c0cbcab3d7a0e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a74413a9f6b657d2673c0cbcab3d7a0e0">calculateGeodeticLatitude</a> (const Eigen::Vector3d cartesianState, const double equatorialRadius, const double flattening, const double tolerance)</td></tr>
<tr class="memdesc:a74413a9f6b657d2673c0cbcab3d7a0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the geodetic latitude of a position vector.  <a href="#a74413a9f6b657d2673c0cbcab3d7a0e0">More...</a><br /></td></tr>
<tr class="separator:a74413a9f6b657d2673c0cbcab3d7a0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59382fb61e05acb0988cf99e02990839"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a59382fb61e05acb0988cf99e02990839">convertCartesianToCylindrical</a> (const Eigen::Vector3d &amp;cartesianCoordinates)</td></tr>
<tr class="memdesc:a59382fb61e05acb0988cf99e02990839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Cartesian to cylindrical coordinates.  <a href="#a59382fb61e05acb0988cf99e02990839">More...</a><br /></td></tr>
<tr class="separator:a59382fb61e05acb0988cf99e02990839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7808dee47f1bb62b963b7c48105fd9ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a7808dee47f1bb62b963b7c48105fd9ec">convertCartesianToCylindricalState</a> (const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;cartesianState)</td></tr>
<tr class="memdesc:a7808dee47f1bb62b963b7c48105fd9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Cartesian to cylindrical state.  <a href="#a7808dee47f1bb62b963b7c48105fd9ec">More...</a><br /></td></tr>
<tr class="separator:a7808dee47f1bb62b963b7c48105fd9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf167dfb5de2f5d2caf5bd159630ff08"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#acf167dfb5de2f5d2caf5bd159630ff08">convertCartesianToGeodeticCoordinates</a> (const Eigen::Vector3d cartesianCoordinates, const double equatorialRadius, const double flattening, const double tolerance)</td></tr>
<tr class="memdesc:acf167dfb5de2f5d2caf5bd159630ff08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate geodetic coordinates ( altitude, geodetic latitude, longitude ) of a position vector.  <a href="#acf167dfb5de2f5d2caf5bd159630ff08">More...</a><br /></td></tr>
<tr class="separator:acf167dfb5de2f5d2caf5bd159630ff08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebbda12f726ee9964d2c0e82f7b06b5"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:a8ebbda12f726ee9964d2c0e82f7b06b5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; ScalarType, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a8ebbda12f726ee9964d2c0e82f7b06b5">convertCartesianToSpherical</a> (const Eigen::Matrix&lt; ScalarType, 3, 1 &gt; &amp;cartesianCoordinates)</td></tr>
<tr class="memdesc:a8ebbda12f726ee9964d2c0e82f7b06b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Cartesian (x,y,z) to spherical (radius, zenith, azimuth) coordinates.  <a href="#a8ebbda12f726ee9964d2c0e82f7b06b5">More...</a><br /></td></tr>
<tr class="separator:a8ebbda12f726ee9964d2c0e82f7b06b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b96aea9a80ae28341e8aef0238a65c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a81b96aea9a80ae28341e8aef0238a65c">convertCartesianToSphericalState</a> (const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;cartesianState)</td></tr>
<tr class="memdesc:a81b96aea9a80ae28341e8aef0238a65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Cartesian to spherical state.  <a href="#a81b96aea9a80ae28341e8aef0238a65c">More...</a><br /></td></tr>
<tr class="separator:a81b96aea9a80ae28341e8aef0238a65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f6a63fbfb9f2b90af9d48d9e56339e"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af4f6a63fbfb9f2b90af9d48d9e56339e">convertCylindricalToCartesian</a> (const double radius, const double azimuthAngle, const double z)</td></tr>
<tr class="memdesc:af4f6a63fbfb9f2b90af9d48d9e56339e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert cylindrical to Cartesian coordinates.  <a href="#af4f6a63fbfb9f2b90af9d48d9e56339e">More...</a><br /></td></tr>
<tr class="separator:af4f6a63fbfb9f2b90af9d48d9e56339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8806b6ecf13d70823b93a086c3be92e6"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a8806b6ecf13d70823b93a086c3be92e6">convertCylindricalToCartesian</a> (const Eigen::Vector3d &amp;cylindricalCoordinates)</td></tr>
<tr class="memdesc:a8806b6ecf13d70823b93a086c3be92e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert cylindrical to cartesian coordinates.  <a href="#a8806b6ecf13d70823b93a086c3be92e6">More...</a><br /></td></tr>
<tr class="separator:a8806b6ecf13d70823b93a086c3be92e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7981d0d2432051871fc32faea2b5c98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ad7981d0d2432051871fc32faea2b5c98">convertCylindricalToCartesianState</a> (const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;cylindricalState)</td></tr>
<tr class="memdesc:ad7981d0d2432051871fc32faea2b5c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert cylindrical to Cartesian state.  <a href="#ad7981d0d2432051871fc32faea2b5c98">More...</a><br /></td></tr>
<tr class="separator:ad7981d0d2432051871fc32faea2b5c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af815bd9c14e04060c3764727c05aaac3"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af815bd9c14e04060c3764727c05aaac3">convertGeodeticToCartesianCoordinates</a> (const Eigen::Vector3d geodeticCoordinates, const double equatorialRadius, const double flattening)</td></tr>
<tr class="memdesc:af815bd9c14e04060c3764727c05aaac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the Cartesian position from geodetic coordinates.  <a href="#af815bd9c14e04060c3764727c05aaac3">More...</a><br /></td></tr>
<tr class="separator:af815bd9c14e04060c3764727c05aaac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9657a0b577dcf70da6ed897c71206385"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a9657a0b577dcf70da6ed897c71206385">convertPositionElements</a> (const Eigen::Vector3d &amp;originalElements, const <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106e">PositionElementTypes</a> originalElementType, const <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106e">PositionElementTypes</a> convertedElementType, const std::shared_ptr&lt; <a class="el" href="../../db/d9d/classtudat_1_1basic__astrodynamics_1_1_body_shape_model.html">basic_astrodynamics::BodyShapeModel</a> &gt; shapeModel, const double tolerance)</td></tr>
<tr class="memdesc:a9657a0b577dcf70da6ed897c71206385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert a position from one representation to another.  <a href="#a9657a0b577dcf70da6ed897c71206385">More...</a><br /></td></tr>
<tr class="separator:a9657a0b577dcf70da6ed897c71206385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb5f8b82ba585939c5f70f7e6bb1ecd"><td class="memTemplParams" colspan="2">template&lt;typename StateScalarType  = double&gt; </td></tr>
<tr class="memitem:a1cb5f8b82ba585939c5f70f7e6bb1ecd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; StateScalarType, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a1cb5f8b82ba585939c5f70f7e6bb1ecd">convertSphericalToCartesian</a> (const Eigen::Matrix&lt; StateScalarType, 3, 1 &gt; &amp;sphericalCoordinates)</td></tr>
<tr class="memdesc:a1cb5f8b82ba585939c5f70f7e6bb1ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert spherical (radius, zenith, azimuth) to Cartesian (x,y,z) coordinates.  <a href="#a1cb5f8b82ba585939c5f70f7e6bb1ecd">More...</a><br /></td></tr>
<tr class="separator:a1cb5f8b82ba585939c5f70f7e6bb1ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82d139463ffbe918e976dc8c57c62e8"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af82d139463ffbe918e976dc8c57c62e8">convertSphericalToCartesianGradient</a> (const Eigen::Vector3d &amp;sphericalGradient, const Eigen::Vector3d &amp;cartesianCoordinates)</td></tr>
<tr class="memdesc:af82d139463ffbe918e976dc8c57c62e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert spherical to Cartesian gradient.  <a href="#af82d139463ffbe918e976dc8c57c62e8">More...</a><br /></td></tr>
<tr class="separator:af82d139463ffbe918e976dc8c57c62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1064d23e1fe0993b63d635d2f18fe273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a1064d23e1fe0993b63d635d2f18fe273">convertSphericalToCartesianState</a> (const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;sphericalState)</td></tr>
<tr class="memdesc:a1064d23e1fe0993b63d635d2f18fe273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert spherical to Cartesian state.  <a href="#a1064d23e1fe0993b63d635d2f18fe273">More...</a><br /></td></tr>
<tr class="separator:a1064d23e1fe0993b63d635d2f18fe273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5660622c38e6f9b5de8d37b54fa7fb5e"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a5660622c38e6f9b5de8d37b54fa7fb5e">getDerivativeOfSphericalToCartesianGradient</a> (const Eigen::Vector3d &amp;sphericalGradient, const Eigen::Vector3d &amp;cartesianCoordinates, std::vector&lt; Eigen::Matrix3d &gt; &amp;subMatrices)</td></tr>
<tr class="memdesc:a5660622c38e6f9b5de8d37b54fa7fb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the derivative of the Cartesian gradient w.r.t.  <a href="#a5660622c38e6f9b5de8d37b54fa7fb5e">More...</a><br /></td></tr>
<tr class="separator:a5660622c38e6f9b5de8d37b54fa7fb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993ccb0d6440d40ddd73f38c71ef799e"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a993ccb0d6440d40ddd73f38c71ef799e">getDerivativeOfSphericalToCartesianGradient</a> (const Eigen::Vector3d &amp;sphericalGradient, const Eigen::Vector3d &amp;cartesianCoordinates)</td></tr>
<tr class="memdesc:a993ccb0d6440d40ddd73f38c71ef799e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the derivative of the Cartesian gradient w.r.t.  <a href="#a993ccb0d6440d40ddd73f38c71ef799e">More...</a><br /></td></tr>
<tr class="separator:a993ccb0d6440d40ddd73f38c71ef799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94662f4fc9f695ac06bb30bf6f261074"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a94662f4fc9f695ac06bb30bf6f261074">getSphericalToCartesianGradientMatrix</a> (const Eigen::Vector3d &amp;cartesianCoordinates)</td></tr>
<tr class="memdesc:a94662f4fc9f695ac06bb30bf6f261074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix by which to precompute a spherical gradient vector to obtain the Cartesian gradient.  <a href="#a94662f4fc9f695ac06bb30bf6f261074">More...</a><br /></td></tr>
<tr class="separator:a94662f4fc9f695ac06bb30bf6f261074"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aff78ce49131008b3ee13015cc7114586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff78ce49131008b3ee13015cc7114586">&#9670;&nbsp;</a></span>StateElementTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aff78ce49131008b3ee13015cc7114586">tudat::coordinate_conversions::StateElementTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aff78ce49131008b3ee13015cc7114586a196031f20e3a89aeba236c93bd6847bd"></a>cartesian_state&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aff78ce49131008b3ee13015cc7114586a42ace40c5a97139d9ca61aeb9af16e17"></a>keplerian_state&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aff78ce49131008b3ee13015cc7114586ad168417d7d7980a7eae4e05c13eb5789"></a>modified_equinoctial_state&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aff78ce49131008b3ee13015cc7114586a3afce2f3d6691df696c5e82726aea2da"></a>unified_state_model_quaternions_state&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aff78ce49131008b3ee13015cc7114586a20326a506d57dc61361dfb68b78e8557"></a>unified_state_model_modified_rodrigues_parameters_state&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aff78ce49131008b3ee13015cc7114586ad9036d766c347a864ebe4598a3bf38f7"></a>unified_state_model_exponential_map_state&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/df1/state_representation_conversions_8h_source.html#l00032">32</a> of file <a class="el" href="../../d8/df1/state_representation_conversions_8h_source.html">stateRepresentationConversions.h</a>.</p>

</div>
</div>
<a id="a4e504281e15b897419420663300c106e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e504281e15b897419420663300c106e">&#9670;&nbsp;</a></span>PositionElementTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106e">tudat::coordinate_conversions::PositionElementTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4e504281e15b897419420663300c106ea641f0af1ef657ae42b959ee6f988a6a3"></a>cartesian_position&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4e504281e15b897419420663300c106ea5f31201b9463b4bbd079378db4181828"></a>spherical_position&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4e504281e15b897419420663300c106ea747df972a51b4f58fd49792836e75a50"></a>geodetic_position&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d8/df1/state_representation_conversions_8h_source.html#l00043">43</a> of file <a class="el" href="../../d8/df1/state_representation_conversions_8h_source.html">stateRepresentationConversions.h</a>.</p>

</div>
</div>
<a id="abb6d2084cdf9790a922a6db2e8b5840c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6d2084cdf9790a922a6db2e8b5840c">&#9670;&nbsp;</a></span>SphericalCoordinateIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#abb6d2084cdf9790a922a6db2e8b5840c">tudat::coordinate_conversions::SphericalCoordinateIndices</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spherical coordinate indices, for position and velocity components. With r the radius, theta the azimuthal angle, phi the elevational angle. Vr, Vtheta, Vphi are the velocities along the corresponding base vectors of r, theta, phi. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abb6d2084cdf9790a922a6db2e8b5840ca7074a15eee73e60af3b82279fde8d9b0"></a>radiusSphericalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abb6d2084cdf9790a922a6db2e8b5840cab2c0704d1a58f152cb64a694f3a68eac"></a>azimuthSphericalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abb6d2084cdf9790a922a6db2e8b5840ca4ea66f82a71fd66d95c2d77e4e20590d"></a>elevationSphericalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abb6d2084cdf9790a922a6db2e8b5840ca4595d181bc65b1d236332e266b7a9c2e"></a>radialVelocitySphericalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abb6d2084cdf9790a922a6db2e8b5840ca57de322cd1fc1a215f38b1efa7ce00a0"></a>azimuthVelocitySphericalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abb6d2084cdf9790a922a6db2e8b5840ca7f7603fe6b2f1ae6bb690a291a882331"></a>elevationVelocitySphericalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00121">121</a> of file <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html">coordinateConversions.h</a>.</p>

</div>
</div>
<a id="af7fa82bea6358f0d3e26482aa11a50ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fa82bea6358f0d3e26482aa11a50ee">&#9670;&nbsp;</a></span>CylindricalCoordinateIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#af7fa82bea6358f0d3e26482aa11a50ee">tudat::coordinate_conversions::CylindricalCoordinateIndices</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cylindrical coordinate vector indices, for position and velocity components. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af7fa82bea6358f0d3e26482aa11a50eea7d2bfec7fb93d117387abf3a7b23998c"></a>rCylindricalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af7fa82bea6358f0d3e26482aa11a50eea3eb72df42b4c40a607835437481443b3"></a>thetaCylindricalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af7fa82bea6358f0d3e26482aa11a50eea00c10bd07d1c40247ab6c8478c3972e1"></a>zCylindricalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af7fa82bea6358f0d3e26482aa11a50eea5deb8fbd197d973ffcc46cb42b03853b"></a>rDotCylindricalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af7fa82bea6358f0d3e26482aa11a50eeada801aade4f6b827507509529a5af6ac"></a>vThetaCylindricalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af7fa82bea6358f0d3e26482aa11a50eeaba4feec5b2ef495fcf10efd77a0b8c15"></a>zDotCylindricalCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00135">135</a> of file <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html">coordinateConversions.h</a>.</p>

</div>
</div>
<a id="ae79813c5dfc8119739a637cabd5f88ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79813c5dfc8119739a637cabd5f88ea">&#9670;&nbsp;</a></span>CartesianCoordinateIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#ae79813c5dfc8119739a637cabd5f88ea">tudat::coordinate_conversions::CartesianCoordinateIndices</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cartesian coordinate vector indices, for position and velocity components. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae79813c5dfc8119739a637cabd5f88eaab772b62b1d6d4f8975883bafa8512f0b"></a>xCartesianCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae79813c5dfc8119739a637cabd5f88eaab21d79431b6645ae5491b9bea1660fc9"></a>yCartesianCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae79813c5dfc8119739a637cabd5f88eaaf51c9c83a5b2d22739edae60c4cd011f"></a>zCartesianCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae79813c5dfc8119739a637cabd5f88eaa49dd89be31f1a72935f2499dcb6c3866"></a>xDotCartesianCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae79813c5dfc8119739a637cabd5f88eaa819a1ec07aacfd6aa910bea30262e537"></a>yDotCartesianCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae79813c5dfc8119739a637cabd5f88eaae89d0b57911de2749977df4c1647d89c"></a>zDotCartesianCoordinateIndex&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00149">149</a> of file <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html">coordinateConversions.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a04c0028e09b2dbefab4d99d6441075b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c0028e09b2dbefab4d99d6441075b7">&#9670;&nbsp;</a></span>calculateEllipticity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::coordinate_conversions::calculateEllipticity </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>flattening</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the ellipticity of an ellipsoid from its flattening. From Montenbruck &amp; Gill (2000). Note: The ellipticity is not to be confused with the eccentricity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flattening</td><td>Flattening of the ellipsoid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ellipticity of the ellipsoid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00029">29</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00117">calculateAltitudeOverOblateSpheroid()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00144">calculateGeodeticLatitude()</a>, and <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00160">convertCartesianToGeodeticCoordinates()</a>.</p>

</div>
</div>
<a id="aadf522731643441bb47479a2ea015385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf522731643441bb47479a2ea015385">&#9670;&nbsp;</a></span>calculateGeodeticCoordinatesAuxiliaryQuantities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; tudat::coordinate_conversions::calculateGeodeticCoordinatesAuxiliaryQuantities </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>cartesianPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>equatorialRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>ellipticity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates auxiliary quantities for geodetic coordinate conversions. (Montenbruck &amp; Gill, 2010, Fig 5.12). The auxiliary quantities are determined by creating a line through the cartesianPosition, perpendicular to the surface and finding its intercept with the z-axis. The distance between the body surface and the z-axis intercept is the first auxiliary quantity, the offset in z-direction of the intersect point from the origin is the second auxiliary variable. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianPosition</td><td>Cartesian position in body-fixed frame where altitude is to be determined. </td></tr>
    <tr><td class="paramname">equatorialRadius</td><td>Equatorial radius of oblate spheroid. </td></tr>
    <tr><td class="paramname">ellipticity</td><td>Ellipticity of oblate spheroid. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Convergence criterion for iterative algorithm that is employed. Represents the required change of position (in m) between two iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Auxiliary parameters for geodetic coordinate conversions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00036">36</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00117">calculateAltitudeOverOblateSpheroid()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00144">calculateGeodeticLatitude()</a>, and <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00160">convertCartesianToGeodeticCoordinates()</a>.</p>

</div>
</div>
<a id="af815bd9c14e04060c3764727c05aaac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af815bd9c14e04060c3764727c05aaac3">&#9670;&nbsp;</a></span>convertGeodeticToCartesianCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::coordinate_conversions::convertGeodeticToCartesianCoordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>geodeticCoordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>equatorialRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>flattening</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the Cartesian position from geodetic coordinates (altitude, geodetic latitude, longitude). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geodeticCoordinates</td><td>Geodetic coordinates w.r.t. given body. </td></tr>
    <tr><td class="paramname">equatorialRadius</td><td>Equatorial radius of oblate spheroid. </td></tr>
    <tr><td class="paramname">flattening</td><td>Flattening of oblate spheroid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cartesian position in body-fixed frame. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00082">82</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/dc5/state_representation_conversions_8cpp_source.html#l00023">convertPositionElements()</a>.</p>

</div>
</div>
<a id="a7a6a98585e107eee2685198f9e90e9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6a98585e107eee2685198f9e90e9bc">&#9670;&nbsp;</a></span>calculateAltitudeOverOblateSpheroid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::coordinate_conversions::calculateAltitudeOverOblateSpheroid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>cartesianPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>zInterceptOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>interceptToSurfaceDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the altitude over an oblate spheroid of a position vector. This function gets the auxiliary variables(see calculateGeodeticCoordinatesAuxiliaryQuantities) as input. These values are determined by drawing the line L from cartesianPosition perpendicular to the ellipsoid and calculating the intercept with the z-axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianPosition</td><td>Cartesian position in body-fixed frame where altitude is to be determined. </td></tr>
    <tr><td class="paramname">zInterceptOffset</td><td>Offset of intercept of line L with z-axis from origin in z-direction. </td></tr>
    <tr><td class="paramname">interceptToSurfaceDistance</td><td>Distance from intercept of line L with z-axis to body surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Altitude above specified oblate spheroid at requested point. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#aadf522731643441bb47479a2ea015385" title="Calculate auxiliary quantities for geodetic coordinate conversions. ">calculateGeodeticCoordinatesAuxiliaryQuantities</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00105">105</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00117">calculateAltitudeOverOblateSpheroid()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00160">convertCartesianToGeodeticCoordinates()</a>, and <a class="el" href="../../d8/d67/oblate_spheroid_body_shape_model_8h_source.html#l00061">tudat::basic_astrodynamics::OblateSpheroidBodyShapeModel::getAltitude()</a>.</p>

</div>
</div>
<a id="a01504cc9d29bc382d1289119fff5fc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01504cc9d29bc382d1289119fff5fc49">&#9670;&nbsp;</a></span>calculateAltitudeOverOblateSpheroid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::coordinate_conversions::calculateAltitudeOverOblateSpheroid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>cartesianPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>equatorialRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>flattening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the altitude over an oblate spheroid of a position vector. The algorithm that is used is iterative, so that it requires a tolerance (in m) for the difference of associated geodetic position between two iterations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianPosition</td><td>Cartesian position in body-fixed frame where altitude is to be determined. </td></tr>
    <tr><td class="paramname">equatorialRadius</td><td>Equatorial radius of oblate spheroid. </td></tr>
    <tr><td class="paramname">flattening</td><td>Flattening of oblate spheroid. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Convergence criterion for iterative algorithm that is employed. Represents the required change of position (in m) between two iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Altitude above specified oblate spheroid at requested point. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00117">117</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00105">calculateAltitudeOverOblateSpheroid()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00029">calculateEllipticity()</a>, and <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00036">calculateGeodeticCoordinatesAuxiliaryQuantities()</a>.</p>

</div>
</div>
<a id="ae4171db69638b9ed13b07e6e1528ddec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4171db69638b9ed13b07e6e1528ddec">&#9670;&nbsp;</a></span>calculateGeodeticLatitude() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::coordinate_conversions::calculateGeodeticLatitude </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>cartesianPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>zInterceptOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the geodetic latitude from Cartesian position and offset of z-intercept. This intercept is determined by drawing the line from cartesianPosition perpendicular to the ellipsoid and calculating the offset from the origin where it intercepts the z-axis. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianPosition</td><td>Cartesian position in body-fixed frame where geodetic latitude is to be determined. </td></tr>
    <tr><td class="paramname">zInterceptOffset</td><td>Offset from origin of intersection with z-axis of line perpendicular to surface from cartesianPosition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodetic latitude above specified oblate spheroid at requested point. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00133">133</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00144">calculateGeodeticLatitude()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00160">convertCartesianToGeodeticCoordinates()</a>, <a class="el" href="../../d8/d67/oblate_spheroid_body_shape_model_8h_source.html#l00094">tudat::basic_astrodynamics::OblateSpheroidBodyShapeModel::getGeodeticLatitude()</a>, and <a class="el" href="../../d4/d4b/ground_station_state_8cpp_source.html#l00103">tudat::ground_stations::getRotationQuaternionFromBodyFixedToTopocentricFrame()</a>.</p>

</div>
</div>
<a id="a74413a9f6b657d2673c0cbcab3d7a0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74413a9f6b657d2673c0cbcab3d7a0e0">&#9670;&nbsp;</a></span>calculateGeodeticLatitude() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tudat::coordinate_conversions::calculateGeodeticLatitude </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>cartesianPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>equatorialRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>flattening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the geodetic latitude of a position vector on an oblate spheroid. The algorithm that is used is iterative, so that it requires a tolerance (in m) for the difference of associated geodetic position between two iterations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianPosition</td><td>Cartesian position in body-fixed frame where geodetic latitude is to be determined. </td></tr>
    <tr><td class="paramname">equatorialRadius</td><td>Equatorial radius of oblate spheroid. </td></tr>
    <tr><td class="paramname">flattening</td><td>Flattening of oblate spheroid. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Convergence criterion for iterative algorithm that is employed. Represents the required change of position (in m) between two iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodetic latitude above specified oblate spheroid at requested point. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00144">144</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00029">calculateEllipticity()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00036">calculateGeodeticCoordinatesAuxiliaryQuantities()</a>, and <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00133">calculateGeodeticLatitude()</a>.</p>

</div>
</div>
<a id="acf167dfb5de2f5d2caf5bd159630ff08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf167dfb5de2f5d2caf5bd159630ff08">&#9670;&nbsp;</a></span>convertCartesianToGeodeticCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::coordinate_conversions::convertCartesianToGeodeticCoordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d&#160;</td>
          <td class="paramname"><em>cartesianCoordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>equatorialRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>flattening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate geodetic coordinates (altitude, geodetic latitude, longitude) of a position vector.</p>
<p>Calculates the geodetic coordinates (altitude, geodetic latitude, longitude) of a position vector. The algorithm that is used is iterative, so that it requires a tolerance (in m) for the difference of associated geodetic position between two iterations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianCoordinates</td><td>Cartesian position in body-fixed frame where geodetic coordinates are to be determined. </td></tr>
    <tr><td class="paramname">equatorialRadius</td><td>Equatorial radius of oblate spheroid. </td></tr>
    <tr><td class="paramname">flattening</td><td>Flattening of oblate spheroid. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Convergence criterion for iterative algorithm that is employed. Represents the required change of position (in m) between two iterations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Geodetic coordinates at requested point. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00160">160</a> of file <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html">geodeticCoordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00105">calculateAltitudeOverOblateSpheroid()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00029">calculateEllipticity()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00036">calculateGeodeticCoordinatesAuxiliaryQuantities()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00133">calculateGeodeticLatitude()</a>, and <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00088">convertCartesianToSpherical()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/dc5/state_representation_conversions_8cpp_source.html#l00023">convertPositionElements()</a>, and <a class="el" href="../../d8/d67/oblate_spheroid_body_shape_model_8h_source.html#l00077">tudat::basic_astrodynamics::OblateSpheroidBodyShapeModel::getGeodeticPositionWrtShape()</a>.</p>

</div>
</div>
<a id="a9657a0b577dcf70da6ed897c71206385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9657a0b577dcf70da6ed897c71206385">&#9670;&nbsp;</a></span>convertPositionElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::coordinate_conversions::convertPositionElements </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>originalElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106e">PositionElementTypes</a>&#160;</td>
          <td class="paramname"><em>originalElementTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d68/namespacetudat_1_1coordinate__conversions.html#a4e504281e15b897419420663300c106e">PositionElementTypes</a>&#160;</td>
          <td class="paramname"><em>convertedElementTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="../../db/d9d/classtudat_1_1basic__astrodynamics_1_1_body_shape_model.html">basic_astrodynamics::BodyShapeModel</a> &gt;&#160;</td>
          <td class="paramname"><em>shapeModel</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.0E-4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to convert a position from one representation to another </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalElements</td><td>Position in element type given by originalElementTypes </td></tr>
    <tr><td class="paramname">originalElementTypes</td><td>Element type used for input. </td></tr>
    <tr><td class="paramname">convertedElementTypes</td><td>Element type to which originalElements is to be converted. </td></tr>
    <tr><td class="paramname">shapeModel</td><td>Shape model associated with position (only required for specific element types, e.g. geodetic) default nullptr. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance used for conversion (only required for specific element types, e.g. geodetic), default 0.1 mm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position in requested element type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dd/dc5/state_representation_conversions_8cpp_source.html#l00023">23</a> of file <a class="el" href="../../dd/dc5/state_representation_conversions_8cpp_source.html">stateRepresentationConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/df1/state_representation_conversions_8h_source.html#l00045">cartesian_position</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00160">convertCartesianToGeodeticCoordinates()</a>, <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00088">convertCartesianToSpherical()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00082">convertGeodeticToCartesianCoordinates()</a>, <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00050">convertSphericalToCartesian()</a>, <a class="el" href="../../d8/df1/state_representation_conversions_8h_source.html#l00047">geodetic_position</a>, <a class="el" href="../../db/d5a/spice_interface_8cpp_source.html#l00229">tudat::spice_interface::getAverageRadius()</a>, <a class="el" href="../../d8/d67/oblate_spheroid_body_shape_model_8h_source.html#l00126">tudat::basic_astrodynamics::OblateSpheroidBodyShapeModel::getFlattening()</a>, <a class="el" href="../../d6/d70/mathematical_constants_8h_source.html#l00059">tudat::mathematical_constants::PI</a>, <a class="el" href="../../d8/df1/state_representation_conversions_8h_source.html#l00046">spherical_position</a>, and <a class="el" href="../../d6/d70/mathematical_constants_8h_source.html#l00071">TUDAT_NAN</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/d4b/ground_station_state_8cpp_source.html#l00066">tudat::ground_stations::GroundStationState::resetGroundStationPositionAtEpoch()</a>.</p>

</div>
</div>
<a id="af4f6a63fbfb9f2b90af9d48d9e56339e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f6a63fbfb9f2b90af9d48d9e56339e">&#9670;&nbsp;</a></span>convertCylindricalToCartesian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::coordinate_conversions::convertCylindricalToCartesian </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>azimuthAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts cylindrical to Cartesian coordinates. Schematic representation can be found on, e.g., <a href="http://mathworld.wolfram.com/CylindricalCoordinates.html">http://mathworld.wolfram.com/CylindricalCoordinates.html</a>. The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius and <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle [rad]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} x &amp;=&amp; r\cos \theta \\ y &amp;=&amp; r\sin \theta \\ z &amp;=&amp; z \\ \end{eqnarray*}" src="../../form_107.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>Cylindrical radial coordinate r. </td></tr>
    <tr><td class="paramname">azimuthAngle</td><td>Cylindrical azimuthal coordinate <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> [rad]. </td></tr>
    <tr><td class="paramname">z</td><td>Cylindrical height coordinate z. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of Cartesian coordinates [x,y,z]. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00036">36</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00080">convertCylindricalToCartesianState()</a>, and <a class="el" href="../../d6/de6/conical_frustum_8cpp_source.html#l00043">tudat::geometric_shapes::ConicalFrustum::getSurfacePoint()</a>.</p>

</div>
</div>
<a id="a8806b6ecf13d70823b93a086c3be92e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8806b6ecf13d70823b93a086c3be92e6">&#9670;&nbsp;</a></span>convertCylindricalToCartesian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::coordinate_conversions::convertCylindricalToCartesian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>cylindricalCoordinates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts cylindrical to cartesian coordinates. Schematic representation can be found on, e.g., <a href="http://mathworld.wolfram.com/CylindricalCoordinates.html">http://mathworld.wolfram.com/CylindricalCoordinates.html</a>. The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius and <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle [rad]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} x &amp;=&amp; r\cos \theta \\ y &amp;=&amp; r\sin \theta \\ z &amp;=&amp; z \\ \end{eqnarray*}" src="../../form_107.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cylindricalCoordinates</td><td>Vector of cylindrical coordinates [r,theta,z]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of Cartesian coordinates [x,y,z]. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00057">57</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

</div>
</div>
<a id="ad7981d0d2432051871fc32faea2b5c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7981d0d2432051871fc32faea2b5c98">&#9670;&nbsp;</a></span>convertCylindricalToCartesianState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> tudat::coordinate_conversions::convertCylindricalToCartesianState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;&#160;</td>
          <td class="paramname"><em>cylindricalState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts cylindrical to Cartesian state. Schematic representation can be found on, e.g., <a href="http://mathworld.wolfram.com/CylindricalCoordinates.html">http://mathworld.wolfram.com/CylindricalCoordinates.html</a> and <a href="http://staffweb.cms.gre.ac.uk/~ct02/research/thesis/node26.html">http://staffweb.cms.gre.ac.uk/~ct02/research/thesis/node26.html</a>. The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius and <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle [rad]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} x &amp;=&amp; r\cos \theta \\ y &amp;=&amp; r\sin \theta \\ z &amp;=&amp; z \\ \dot{x} &amp;=&amp; V_r\cos{\theta} - V_{\theta}\sin{theta} \\ \dot{y} &amp;=&amp; V_r\sin{\theta} + V_{\theta}\cos{theta} \\ \dot{z} &amp;=&amp; V_z \end{eqnarray*}" src="../../form_108.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cylindricalState</td><td>Vector of cylindrical state [r,theta,z,Vr,Vtheta,Vz], where Vtheta = r*thetadot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of Cartesian state [x,y,z,xdot,ydot,zdot]. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00080">80</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00036">convertCylindricalToCartesian()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/dcf/hodographic_shaping_8cpp_source.html#l00473">tudat::shape_based_methods::HodographicShaping::computeCurrentStateVector()</a>.</p>

</div>
</div>
<a id="a59382fb61e05acb0988cf99e02990839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59382fb61e05acb0988cf99e02990839">&#9670;&nbsp;</a></span>convertCartesianToCylindrical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::coordinate_conversions::convertCartesianToCylindrical </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>cartesianCoordinates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts Cartesian to cylindrical coordinates. Schematic representation can be found on, e.g., <a href="http://mathworld.wolfram.com/CylindricalCoordinates.html">http://mathworld.wolfram.com/CylindricalCoordinates.html</a>. The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius and <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle [rad] [0,2 <img class="formulaInl" alt="$ \pi $" src="../../form_109.png"/>]: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} r &amp;=&amp; \sqrt{x^2+y^2} \\ \theta &amp;=&amp; \arctan{\frac{y}{x}} \\ z &amp;=&amp; z \end{eqnarray*}" src="../../form_110.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianCoordinates</td><td>Vector of Cartesian coordinates [x,y,z]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of cylindrical coordinates [r,theta,z]. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00121">121</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../df/d63/basic_mathematics_functions_8h_source.html#l00056">tudat::basic_mathematics::computeModulo()</a>, and <a class="el" href="../../d6/d70/mathematical_constants_8h_source.html#l00059">tudat::mathematical_constants::PI</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00159">convertCartesianToCylindricalState()</a>.</p>

</div>
</div>
<a id="a7808dee47f1bb62b963b7c48105fd9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7808dee47f1bb62b963b7c48105fd9ec">&#9670;&nbsp;</a></span>convertCartesianToCylindricalState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> tudat::coordinate_conversions::convertCartesianToCylindricalState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;&#160;</td>
          <td class="paramname"><em>cartesianState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts Cartesian to cylindrical state. Schematic representation can be found on, e.g., <a href="http://mathworld.wolfram.com/CylindricalCoordinates.html">http://mathworld.wolfram.com/CylindricalCoordinates.html</a> and <a href="http://staffweb.cms.gre.ac.uk/~ct02/research/thesis/node26.html">http://staffweb.cms.gre.ac.uk/~ct02/research/thesis/node26.html</a>. The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius, <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle [rad] [0,2 <img class="formulaInl" alt="$\pi$" src="../../form_111.png"/>] and <img class="formulaInl" alt="$ V_r $" src="../../form_112.png"/>, <img class="formulaInl" alt="$ V_{\theta} $" src="../../form_113.png"/> and <img class="formulaInl" alt="$ V_z $" src="../../form_114.png"/> the linear cylindrical velocities: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} r &amp;=&amp; \sqrt{x^2+y^2} \\ \theta &amp;=&amp; \arctan{\frac{y}{x}} \\ z &amp;=&amp; z \\ V_r = \dot{r} &amp;=&amp; \frac{x\dot{x}+y\dot{y}}{\sqrt{x^2+y^2}} \\ V_{\theta} = r\dot{\theta} &amp;=&amp; \frac{x\dot{y}-y\dot{x}}{\sqrt{x^2+y^2}} \\ V_z = \dot{z} \end{eqnarray*}" src="../../form_115.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianState</td><td>Vector of Cartesian state [x,y,z,xdot,ydot,zdot]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of cylindrical state [r,theta,z,Vr,Vtheta,Vz], where Vtheta = r*thetadot. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00159">159</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00121">convertCartesianToCylindrical()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/dcf/hodographic_shaping_8cpp_source.html#l00430">tudat::shape_based_methods::HodographicShaping::computeCurrentPolarAngle()</a>, and <a class="el" href="../../df/dcf/hodographic_shaping_8cpp_source.html#l00030">tudat::shape_based_methods::HodographicShaping::HodographicShaping()</a>.</p>

</div>
</div>
<a id="a94662f4fc9f695ac06bb30bf6f261074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94662f4fc9f695ac06bb30bf6f261074">&#9670;&nbsp;</a></span>getSphericalToCartesianGradientMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3d tudat::coordinate_conversions::getSphericalToCartesianGradientMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>cartesianCoordinates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute matrix by which to precompute a spherical gradient vector to obtain the Cartesian gradient </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianCoordinates</td><td>Vector with Cartesian position at which gradient is computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix by which to precompute a spherical gradient vector to obtain the Cartesian gradient </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00195">195</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dc4/spherical_harmonics_gravity_model_8cpp_source.html#l00038">tudat::gravitation::computeGeodesyNormalizedGravitationalAccelerationSum()</a>, <a class="el" href="../../d6/d71/spherical_harmonic_partial_functions_8cpp_source.html#l00181">tudat::acceleration_partials::computePartialDerivativeOfBodyFixedSphericalHarmonicAcceleration()</a>, <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00225">convertSphericalToCartesianGradient()</a>, <a class="el" href="../../d1/df9/spherical_harmonic_acceleration_partial_8cpp_source.html#l00403">tudat::acceleration_partials::SphericalHarmonicsGravityPartial::wrtCosineCoefficientBlock()</a>, <a class="el" href="../../d1/df9/spherical_harmonic_acceleration_partial_8cpp_source.html#l00416">tudat::acceleration_partials::SphericalHarmonicsGravityPartial::wrtSineCoefficientBlock()</a>, and <a class="el" href="../../d1/df9/spherical_harmonic_acceleration_partial_8cpp_source.html#l00454">tudat::acceleration_partials::SphericalHarmonicsGravityPartial::wrtTidalModelParameter()</a>.</p>

</div>
</div>
<a id="af82d139463ffbe918e976dc8c57c62e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82d139463ffbe918e976dc8c57c62e8">&#9670;&nbsp;</a></span>convertSphericalToCartesianGradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d tudat::coordinate_conversions::convertSphericalToCartesianGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>sphericalGradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>cartesianCoordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function converts a gradient vector with respect to spherical coordinates to a gradient vector with respect to Cartesian coordinates. The partial derivatives are calculated according to Vallado [2001] as: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \frac{ \partial U }{ \partial x } &amp; = &amp; \frac{ x }{ \sqrt{ x^2 + y^2 +z^2 } } \frac{ \partial U }{ \partial r } - \frac{ x z }{ ( x^2 + y^2 +z^2 ) \sqrt{ x^2 + y^2 } } \frac{ \partial U }{ \partial \phi } - \frac{ y }{ x^2 + y^2 } \frac{ \partial U }{ \partial \lambda } \\ \frac{ \partial U }{ \partial y } &amp; = &amp; \frac{ y }{ \sqrt{ x^2 + y^2 +z^2 } } \frac{ \partial U }{ \partial r } - \frac{ y z }{ ( x^2 + y^2 +z^2 ) \sqrt{ x^2 + y^2 } } \frac{ \partial U }{ \partial \phi } + \frac{ x }{ x^2 + y^2 } \frac{ \partial U }{ \partial \lambda } \\ \frac{ \partial U }{ \partial z } &amp; = &amp; \frac{ z }{ \sqrt{ x^2 + y^2 +z^2 } } \frac{ \partial U }{ \partial r } + \frac{ \sqrt{ x^2 + y^2 } } { x^2 + y^2 +z^2 } \frac{ \partial U }{ \partial \phi } \end{eqnarray*}" src="../../form_116.png"/>
</p>
<p> in which <img class="formulaInl" alt="$ x $" src="../../form_82.png"/>, <img class="formulaInl" alt="$ y $" src="../../form_117.png"/> and <img class="formulaInl" alt="$ z $" src="../../form_118.png"/> are the Cartesian coordinates. <img class="formulaInl" alt="$ U $" src="../../form_119.png"/> is an arbitrary scalar. Radius <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> is the length of the position vector. Elevation <img class="formulaInl" alt="$ \phi $" src="../../form_84.png"/> is the the angle between the position vector and the XY-plane (with the positive direction towards the Z-axis). Azimuth <img class="formulaInl" alt="$ \lambda $" src="../../form_120.png"/> is the dihedral angle about the Z-axis between the X-axis and the position vector (with the positive direction being right-handed about the Z-axis). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphericalGradient</td><td>Vector with partial derivatives with respect to spherical coordinates. The order is important! sphericalGradient( 0 ) = partial derivative with respect to radius, sphericalGradient( 1 ) = partial derivative with respect to elevation, sphericalGradient( 2 ) = partial derivative with respect to azimuth. </td></tr>
    <tr><td class="paramname">cartesianCoordinates</td><td>Vector with Cartesian coordinates. The order is important! cartesianCoordinates( 0 ) = x coordinate, cartesianCoordinates( 1 ) = y coordinate, cartesianCoordinates( 2 ) = z coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector with partial derivatives with respect to Cartesian coordinates. The order is important! cartesianGradient( 0 ) = partial derivative with respect to x coordinate, cartesianGradient( 1 ) = partial derivative with respect to y coordinate, cartesianGradient( 2 ) = partial derivative with respect to z coordinate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00225">225</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00195">getSphericalToCartesianGradientMatrix()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dc4/spherical_harmonics_gravity_model_8cpp_source.html#l00131">tudat::gravitation::computeSingleGeodesyNormalizedGravitationalAcceleration()</a>.</p>

</div>
</div>
<a id="a5660622c38e6f9b5de8d37b54fa7fb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5660622c38e6f9b5de8d37b54fa7fb5e">&#9670;&nbsp;</a></span>getDerivativeOfSphericalToCartesianGradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3d tudat::coordinate_conversions::getDerivativeOfSphericalToCartesianGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>sphericalGradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>cartesianCoordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>subMatrices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to compute the derivative of the Cartesian gradient w.r.t. the Cartesian position, keeping the spherical gradient constant.</p>
<p>the Cartesian position, keeping the spherical gradient constant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphericalGradient</td><td>Value of spherical gradient (derivatives w.r.t. radius, latitude and longitude). </td></tr>
    <tr><td class="paramname">cartesianCoordinates</td><td>Cartesian position at whichr result is to be computed. </td></tr>
    <tr><td class="paramname">subMatrices</td><td>Subcomputations performed by this function: derivatives of results of getSphericalToCartesianGradientMatrix, w.r.t. x, y and z component of cartesianCoordinates, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Require derivative of cartesian gradient. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00234">234</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d71/spherical_harmonic_partial_functions_8cpp_source.html#l00152">tudat::acceleration_partials::computePartialDerivativeOfBodyFixedSphericalHarmonicAcceleration()</a>, and <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00330">getDerivativeOfSphericalToCartesianGradient()</a>.</p>

</div>
</div>
<a id="a993ccb0d6440d40ddd73f38c71ef799e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993ccb0d6440d40ddd73f38c71ef799e">&#9670;&nbsp;</a></span>getDerivativeOfSphericalToCartesianGradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3d tudat::coordinate_conversions::getDerivativeOfSphericalToCartesianGradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>sphericalGradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>cartesianCoordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to compute the derivative of the Cartesian gradient w.r.t. the Cartesian position, keeping the spherical gradient constant.</p>
<p>the Cartesian position, keeping the spherical gradient constant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphericalGradient</td><td>Value of spherical gradient (derivatives w.r.t. radius, latitude and longitude). </td></tr>
    <tr><td class="paramname">cartesianCoordinates</td><td>Cartesian position at whichr result is to be computed.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Require derivative of cartesian gradient. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00330">330</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00234">getDerivativeOfSphericalToCartesianGradient()</a>.</p>

</div>
</div>
<a id="a1064d23e1fe0993b63d635d2f18fe273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1064d23e1fe0993b63d635d2f18fe273">&#9670;&nbsp;</a></span>convertSphericalToCartesianState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> tudat::coordinate_conversions::convertSphericalToCartesianState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;&#160;</td>
          <td class="paramname"><em>sphericalState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a spherical state to a Cartesian state. The transformation matrices are computed according to Torok [2000, pp.10-11].</p>
<p>NOTE: This function is implemented separately from the other conversions due to a different definition of the elevation/zenith angle. This should be consolidated in a future update.</p>
<p>The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius (positive from origin to the point in orbit, in meters), <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle (positive from the x-axis to the y-axis, in radians) and <img class="formulaInl" alt="$ \phi $" src="../../form_84.png"/> the elevation angle (positive from the xy-plane to the z-axis, in radians): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} x &amp;=&amp; r * \cos \phi * \cos \theta\\ y &amp;=&amp; r * \cos \phi * \sin \theta\\ z &amp;=&amp; r * \sin \phi\\ CartesianVelocities = T_{cyl2cart}*T_{sph2cyl}*SphericalVelocities \end{eqnarray*}" src="../../form_121.png"/>
</p>
<p> with </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} T_{sph2cyl} = [ \cos\phi , 0.0 , -\sin \phi ; 0.0 , 1.0 , 0.0 ; \sin\phi , 0.0 , \cos\phi ]\\ T_{cyl2cart} = [ \cos\theta , -\sin\theta , 0.0 ; \sin\theta , \cos\theta , 0.0 ; 0.0 , 0.0 , 1.0 ]\\ \end{eqnarray*}" src="../../form_122.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphericalState</td><td>Vector containing the spherical coordinates and spherical velocities. The order is important! sphericalState( 0 ) = radius r [m], sphericalState( 1 ) = azimuth theta [rad], sphericalState( 2 ) = elevation phi [rad], sphericalState( 3 ) = radial velocity Vr [m/s], sphericalState( 4 ) = azimuthal velocity Vtheta [m/s], sphericalState( 5 ) = elevational velocity Vphi [m/s]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the Cartesian state (both position and velocity, in that order). cartesianState( 0 ) = x [m], cartesianState( 1 ) = y [m], cartesianState( 2 ) = z [m], cartesianState( 3 ) = Vx [m/s], cartesianState( 4 ) = Vy [m/s], cartesianState( 5 ) = Vz [m/s].</dd></dl>
<p>Take care: here the elevation is used, not the zenith angle! </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00339">339</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d40/spherical_shaping_8cpp_source.html#l00528">tudat::shape_based_methods::SphericalShaping::computeCurrentStateVector()</a>, and <a class="el" href="../../db/d40/spherical_shaping_8cpp_source.html#l00608">tudat::shape_based_methods::SphericalShaping::computeThrustAccelerationVector()</a>.</p>

</div>
</div>
<a id="a81b96aea9a80ae28341e8aef0238a65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b96aea9a80ae28341e8aef0238a65c">&#9670;&nbsp;</a></span>convertCartesianToSphericalState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> tudat::coordinate_conversions::convertCartesianToSphericalState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/da5/namespace_eigen.html#a03c917374d8dcb5bb158f2380f92847a">Eigen::Vector6d</a> &amp;&#160;</td>
          <td class="paramname"><em>cartesianState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a Cartesian state to a spherical state. The transformation matrices are computed according to Torok [2000, pp.10-11].</p>
<p>NOTE: This function is implemented separately from the other conversions due to a different definition of the elevation/zenith angle. This should be consolidated in a future update.</p>
<p>The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius (positive from origin to the point in orbit), <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle (positive from the x-axis to the y-axis) and <img class="formulaInl" alt="$ \phi $" src="../../form_84.png"/> the elevation angle (positive from the xy-plane to the z-axis): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} r &amp;=&amp; \sqrt{ x^{ 2 } + y^{ 2 } + z^{ 2 } } \\ \phi &amp;=&amp; \arcsin\frac{ z }{ r } \\ \theta &amp;=&amp; \arctan\frac{ y }{ x } \\ SphericalVelocities = T_{cyl2sph}*T_{cart2cyl}*CartesianVelocities \end{eqnarray*}" src="../../form_123.png"/>
</p>
<p> with </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} T_{cyl2sph} = [ \cos\phi , 0.0 , \sin \phi ; 0.0 , 1.0 , 0.0 ; -\sin\phi , 0.0 , \cos\phi ]\\ T_{cart2cyl} = [ \cos\theta , \sin\theta , 0.0 ; -\sin\theta , \cos\theta , 0.0 ; 0.0 , 0.0 , 1.0 ]\\ \end{eqnarray*}" src="../../form_124.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianState</td><td>Vector containing the Cartesian coordinates and Cartesian velocities. The order is important! cartesianState( 0 ) = x [m], cartesianState( 1 ) = y [m], cartesianState( 2 ) = z [m], cartesianState( 3 ) = Vx [m/s], cartesianState( 4 ) = Vy [m/s], cartesianState( 5 ) = Vz [m/s]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing the spherical state (both position and velocity, in that order). The order is important! sphericalState( 0 ) = radius r [m], sphericalState( 1 ) = azimuth theta [rad], sphericalState( 2 ) = elevation phi [rad], sphericalState( 3 ) = radial velocity Vr [m/s], sphericalState( 4 ) = azimuthal velocity Vtheta [m/s], sphericalState( 5 ) = elevational velocity Vphi [m/s].</dd></dl>
<p>Take care: here the elevation is used, not the zenith! </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html#l00391">391</a> of file <a class="el" href="../../d8/d85/coordinate_conversions_8cpp_source.html">coordinateConversions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/d40/spherical_shaping_8cpp_source.html#l00025">tudat::shape_based_methods::SphericalShaping::SphericalShaping()</a>.</p>

</div>
</div>
<a id="a1cb5f8b82ba585939c5f70f7e6bb1ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb5f8b82ba585939c5f70f7e6bb1ecd">&#9670;&nbsp;</a></span>convertSphericalToCartesian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StateScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; StateScalarType, 3, 1 &gt; tudat::coordinate_conversions::convertSphericalToCartesian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; StateScalarType, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sphericalCoordinates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts spherical to cartesian coordinates. Schematic representation can be found on, e.g., <a href="http://mathworld.wolfram.com/SphericalCoordinates.html">http://mathworld.wolfram.com/SphericalCoordinates.html</a>. The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius, <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle and <img class="formulaInl" alt="$ \phi $" src="../../form_84.png"/> the zenith angle: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} x &amp;=&amp; r\cos\theta\sin\phi \\ y &amp;=&amp; r\sin\theta\sin\phi \\ z &amp;=&amp; r\cos\phi \\ \end{eqnarray*}" src="../../form_105.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sphericalCoordinates</td><td>Vector containing radius, zenith and azimuth (in that order). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing Cartesian coordinates, as calculated from sphericalCoordinates. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00050">50</a> of file <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html">coordinateConversions.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/dc5/state_representation_conversions_8cpp_source.html#l00023">convertPositionElements()</a>, <a class="el" href="../../d7/d12/approximate_planet_positions_circular_coplanar_8cpp_source.html#l00033">tudat::ephemerides::ApproximatePlanetPositionsCircularCoplanar::getCartesianState()</a>, and <a class="el" href="../../dc/d53/sphere_segment_8cpp_source.html#l00043">tudat::geometric_shapes::SphereSegment::getSurfacePoint()</a>.</p>

</div>
</div>
<a id="a8ebbda12f726ee9964d2c0e82f7b06b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebbda12f726ee9964d2c0e82f7b06b5">&#9670;&nbsp;</a></span>convertCartesianToSpherical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; ScalarType, 3, 1 &gt; tudat::coordinate_conversions::convertCartesianToSpherical </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; ScalarType, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cartesianCoordinates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts Cartesian to spherical coordinates. Schematic representation can be found on, e.g., <a href="http://mathworld.wolfram.com/SphericalCoordinates.html">http://mathworld.wolfram.com/SphericalCoordinates.html</a>. The transformation equations are the following, with <img class="formulaInl" alt="$ r $" src="../../form_67.png"/> the radius, <img class="formulaInl" alt="$ \theta $" src="../../form_65.png"/> the azimuth angle and <img class="formulaInl" alt="$ \phi $" src="../../form_84.png"/> the zenith angle: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} r &amp;=&amp; \sqrt{ x^{ 2 } + y^{ 2 } + z^{ 2 } } \\ \theta &amp;=&amp; \arctan\frac{ y }{ x } \\ \phi &amp;=&amp; \arccos\frac{ z }{ r } \\ \end{eqnarray*}" src="../../form_106.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cartesianCoordinates</td><td>Vector containing Cartesian coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector containing sphericalCoordinates radius, zenith and azimuth (in that order), as calculated from sphericalCoordinates. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html#l00088">88</a> of file <a class="el" href="../../d4/df3/coordinate_conversions_8h_source.html">coordinateConversions.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/db9/basic_solid_body_tide_gravity_field_variations_8cpp_source.html#l00073">tudat::gravitation::calculateSolidBodyTideSingleCoefficientSetCorrectionFromAmplitude()</a>, <a class="el" href="../../d5/ddd/spherical_harmonics_gravity_field_8cpp_source.html#l00032">tudat::gravitation::calculateSphericalHarmonicGravitationalPotential()</a>, <a class="el" href="../../db/dc4/spherical_harmonics_gravity_model_8cpp_source.html#l00038">tudat::gravitation::computeGeodesyNormalizedGravitationalAccelerationSum()</a>, <a class="el" href="../../d6/d71/spherical_harmonic_partial_functions_8cpp_source.html#l00181">tudat::acceleration_partials::computePartialDerivativeOfBodyFixedSphericalHarmonicAcceleration()</a>, <a class="el" href="../../db/dc4/spherical_harmonics_gravity_model_8cpp_source.html#l00131">tudat::gravitation::computeSingleGeodesyNormalizedGravitationalAcceleration()</a>, <a class="el" href="../../d2/df5/geodetic_coordinate_conversions_8cpp_source.html#l00160">convertCartesianToGeodeticCoordinates()</a>, <a class="el" href="../../dd/dc5/state_representation_conversions_8cpp_source.html#l00023">convertPositionElements()</a>, <a class="el" href="../../d2/d70/reference_frame_transformations_8cpp_source.html#l00515">tudat::reference_frames::getBodyFixedSphericalPosition()</a>, <a class="el" href="../../d0/db9/basic_solid_body_tide_gravity_field_variations_8cpp_source.html#l00128">tudat::gravitation::BasicSolidBodyTideGravityFieldVariations::setBodyGeometryParameters()</a>, <a class="el" href="../../d9/d20/tidal_love_number_partial_interface_8cpp_source.html#l00278">tudat::orbit_determination::TidalLoveNumberPartialInterface::setCurrentTidalBodyStates()</a>, and <a class="el" href="../../d1/df9/spherical_harmonic_acceleration_partial_8cpp_source.html#l00314">tudat::acceleration_partials::SphericalHarmonicsGravityPartial::update()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 11 2020 09:44:54 for Tudat by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
