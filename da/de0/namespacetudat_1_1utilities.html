<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tudat: tudat::utilities Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tudat
   </div>
   <div id="projectbrief">TU Delft astrodynamics toolbox</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d6d/namespacetudat.html">tudat</a></li><li class="navelem"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tudat::utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af54bd13dd445f57624d887406b2a3f3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af54bd13dd445f57624d887406b2a3f3c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#af54bd13dd445f57624d887406b2a3f3c">addScalarToVector</a> (const std::vector&lt; T &gt; &amp;vector, const double scalar)</td></tr>
<tr class="memdesc:af54bd13dd445f57624d887406b2a3f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to add a double to all entries in an STL vector.  <a href="#af54bd13dd445f57624d887406b2a3f3c">More...</a><br /></td></tr>
<tr class="separator:af54bd13dd445f57624d887406b2a3f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2166e0c5c4b43b40aabee7237d4a28"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ScalarType , int FixedSize&gt; </td></tr>
<tr class="memitem:a8f2166e0c5c4b43b40aabee7237d4a28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a8f2166e0c5c4b43b40aabee7237d4a28">castDynamicToFixedSizeEigenVectorMap</a> (std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, 1 &gt; &gt; &amp;originalMap, std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, FixedSize, 1 &gt; &gt; &amp;fixedSizeMap)</td></tr>
<tr class="separator:a8f2166e0c5c4b43b40aabee7237d4a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename U , typename V , int Rows, int Columns&gt; </td></tr>
<tr class="memitem:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a0f97484a4f7f2e8ecf91f4fd8c7c7cc2">castMatrixMap</a> (const std::map&lt; S, Eigen::Matrix&lt; T, Rows, Columns &gt; &gt; &amp;originalMap, std::map&lt; U, Eigen::Matrix&lt; V, Rows, Columns &gt; &gt; &amp;newTypesMap)</td></tr>
<tr class="memdesc:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to cast a map of <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices from one key/matrix scalar type set to another set.  <a href="#a0f97484a4f7f2e8ecf91f4fd8c7c7cc2">More...</a><br /></td></tr>
<tr class="separator:a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084b530a39126d9f71b9564a1795c4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae084b530a39126d9f71b9564a1795c4a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ae084b530a39126d9f71b9564a1795c4a">convertEigenVectorToStlVector</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;eigenVector)</td></tr>
<tr class="memdesc:ae084b530a39126d9f71b9564a1795c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert Eigen::Vector to std::vector.  <a href="#ae084b530a39126d9f71b9564a1795c4a">More...</a><br /></td></tr>
<tr class="separator:ae084b530a39126d9f71b9564a1795c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2c25526670ce13bcf9468760cfffd"><td class="memTemplParams" colspan="2">template&lt;typename MapKey , typename ScalarType &gt; </td></tr>
<tr class="memitem:a19f2c25526670ce13bcf9468760cfffd"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; MapKey, Eigen::Array&lt; ScalarType, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a19f2c25526670ce13bcf9468760cfffd">convertStlVectorMapToEigenVectorMap</a> (std::map&lt; MapKey, std::vector&lt; ScalarType &gt; &gt; stlVectorMap)</td></tr>
<tr class="memdesc:a19f2c25526670ce13bcf9468760cfffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform from map of std::vector (output of text file reader) to map of Eigen::Array.  <a href="#a19f2c25526670ce13bcf9468760cfffd">More...</a><br /></td></tr>
<tr class="separator:a19f2c25526670ce13bcf9468760cfffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a390209923d63884b1e5af56554cd1"><td class="memTemplParams" colspan="2">template&lt;typename T , int Rows = Eigen::Dynamic&gt; </td></tr>
<tr class="memitem:a38a390209923d63884b1e5af56554cd1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a38a390209923d63884b1e5af56554cd1">convertStlVectorToEigenMatrix</a> (const std::vector&lt; Eigen::Matrix&lt; T, Rows, 1 &gt; &gt; &amp;stlVector)</td></tr>
<tr class="memdesc:a38a390209923d63884b1e5af56554cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert std::vector to Eigen::Matrix.  <a href="#a38a390209923d63884b1e5af56554cd1">More...</a><br /></td></tr>
<tr class="separator:a38a390209923d63884b1e5af56554cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6185604e1e88e807107fba0d5fcd0b81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6185604e1e88e807107fba0d5fcd0b81"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a6185604e1e88e807107fba0d5fcd0b81">convertStlVectorToEigenVector</a> (const std::vector&lt; T &gt; &amp;stlVector)</td></tr>
<tr class="memdesc:a6185604e1e88e807107fba0d5fcd0b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert std::vector to Eigen::Vector.  <a href="#a6185604e1e88e807107fba0d5fcd0b81">More...</a><br /></td></tr>
<tr class="separator:a6185604e1e88e807107fba0d5fcd0b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76098cf72d99535ce14d506f507c2ed5"><td class="memTemplParams" colspan="2">template&lt;typename S , int NumberOfDimensions&gt; </td></tr>
<tr class="memitem:a76098cf72d99535ce14d506f507c2ed5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a76098cf72d99535ce14d506f507c2ed5">copyMultiArray</a> (const boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;arrayToCopy, boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;targetArray)</td></tr>
<tr class="memdesc:a76098cf72d99535ce14d506f507c2ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to copy a multi-array into another multi-array.  <a href="#a76098cf72d99535ce14d506f507c2ed5">More...</a><br /></td></tr>
<tr class="separator:a76098cf72d99535ce14d506f507c2ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8826e25d6f4baf3d1034c2b8237d0c5d"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ScalarType , int NumberOfRows, int NumberOfColumns = 1&gt; </td></tr>
<tr class="memitem:a8826e25d6f4baf3d1034c2b8237d0c5d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, NumberOfColumns &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a8826e25d6f4baf3d1034c2b8237d0c5d">createConcatenatedEigenMatrixFromMapValues</a> (const std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, NumberOfRows, NumberOfColumns &gt; &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:a8826e25d6f4baf3d1034c2b8237d0c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to concatenate matrix values of map.  <a href="#a8826e25d6f4baf3d1034c2b8237d0c5d">More...</a><br /></td></tr>
<tr class="separator:a8826e25d6f4baf3d1034c2b8237d0c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03307b67bd8ee0129a64107e1014a78a"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a03307b67bd8ee0129a64107e1014a78a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a03307b67bd8ee0129a64107e1014a78a">createVectorBlockMatrixHistory</a> (const std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;matrixHistory, std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt; &amp;blockMatrixHistory, const std::pair&lt; int, int &gt; startIndices, const int segmentSize)</td></tr>
<tr class="memdesc:a03307b67bd8ee0129a64107e1014a78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector block history from full matrix history.  <a href="#a03307b67bd8ee0129a64107e1014a78a">More...</a><br /></td></tr>
<tr class="separator:a03307b67bd8ee0129a64107e1014a78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; KeyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a7ff6b03086e9d46b54a9a9b0147e3126">createVectorFromMapKeys</a> (const std::map&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the keys of a map.  <a href="#a7ff6b03086e9d46b54a9a9b0147e3126">More...</a><br /></td></tr>
<tr class="separator:a7ff6b03086e9d46b54a9a9b0147e3126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; VectorArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ab7ffa5bbb8bf510a4e3942a82e36d63c">createVectorFromMapValues</a> (const std::map&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the values of a map.  <a href="#ab7ffa5bbb8bf510a4e3942a82e36d63c">More...</a><br /></td></tr>
<tr class="separator:ab7ffa5bbb8bf510a4e3942a82e36d63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296cc0b23594eca7a78a8500ee568af6"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:a296cc0b23594eca7a78a8500ee568af6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; KeyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a296cc0b23594eca7a78a8500ee568af6">createVectorFromMultiMapKeys</a> (const std::multimap&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:a296cc0b23594eca7a78a8500ee568af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the keys of a multimap.  <a href="#a296cc0b23594eca7a78a8500ee568af6">More...</a><br /></td></tr>
<tr class="separator:a296cc0b23594eca7a78a8500ee568af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="memTemplParams" colspan="2">template&lt;typename VectorArgument , typename KeyType &gt; </td></tr>
<tr class="memitem:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; VectorArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ae625adfdbd740bfdf4c5843bd0c4e414">createVectorFromMultiMapValues</a> (const std::multimap&lt; KeyType, VectorArgument &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a vector from the values of a multimap.  <a href="#ae625adfdbd740bfdf4c5843bd0c4e414">More...</a><br /></td></tr>
<tr class="separator:ae625adfdbd740bfdf4c5843bd0c4e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855f3e9a1ac6f189ecb64eca19bc1c76"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a855f3e9a1ac6f189ecb64eca19bc1c76"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a855f3e9a1ac6f189ecb64eca19bc1c76">createVectorFromVectorOfPairFirsts</a> (const std::vector&lt; std::pair&lt; S, T &gt; &gt; inputVector)</td></tr>
<tr class="separator:a855f3e9a1ac6f189ecb64eca19bc1c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3729d39dbee0d760df4a34697f77d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c3729d39dbee0d760df4a34697f77d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a3c3729d39dbee0d760df4a34697f77d5">doStlVectorContentsMatch</a> (const std::vector&lt; T &gt; &amp;vectorA, const std::vector&lt; T &gt; &amp;vectorB)</td></tr>
<tr class="separator:a3c3729d39dbee0d760df4a34697f77d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7db522751f00da8b6f97f01a03fda73"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:ac7db522751f00da8b6f97f01a03fda73"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ac7db522751f00da8b6f97f01a03fda73">dynamicCastSVectorToTVector</a> (const std::vector&lt; std::shared_ptr&lt; S &gt; &gt; &amp;originalVector)</td></tr>
<tr class="memdesc:ac7db522751f00da8b6f97f01a03fda73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to dynamic cast vector of shared pointers of one type to shared pointers of another type.  <a href="#ac7db522751f00da8b6f97f01a03fda73">More...</a><br /></td></tr>
<tr class="separator:ac7db522751f00da8b6f97f01a03fda73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6d1809b5ffd015d531e456b61172e0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:afb6d1809b5ffd015d531e456b61172e0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#afb6d1809b5ffd015d531e456b61172e0">evaluateFunctionWithoutInputArgumentDependency</a> (std::function&lt; T() &gt; inputFreeFunction, const S dummyInput)</td></tr>
<tr class="separator:afb6d1809b5ffd015d531e456b61172e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab937fe377fe527b8f2f66772c882130f"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ScalarType , int NumberOfRows&gt; </td></tr>
<tr class="memitem:ab937fe377fe527b8f2f66772c882130f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, 1 &gt;, Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#ab937fe377fe527b8f2f66772c882130f">extractKeyAndValuesFromMap</a> (const std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, NumberOfRows, 1 &gt; &gt; &amp;inputMap)</td></tr>
<tr class="memdesc:ab937fe377fe527b8f2f66772c882130f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to extract both keys and values from map, and output them as a pair.  <a href="#ab937fe377fe527b8f2f66772c882130f">More...</a><br /></td></tr>
<tr class="separator:ab937fe377fe527b8f2f66772c882130f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657048a5d7f39201f785d121a385c1fb"><td class="memTemplParams" colspan="2">template&lt;unsigned int NumberOfDimensions&gt; </td></tr>
<tr class="memitem:a657048a5d7f39201f785d121a385c1fb"><td class="memTemplItemLeft" align="right" valign="top">boost::multi_array&lt; double, NumberOfDimensions &gt;::index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a657048a5d7f39201f785d121a385c1fb">getMultiArrayIndex</a> (const typename boost::multi_array&lt; double, NumberOfDimensions &gt; &amp;multiArray, const double *requestedElement, const unsigned short int direction)</td></tr>
<tr class="memdesc:a657048a5d7f39201f785d121a385c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index in nth direction of pointer to single entry in multi-array of doubles.  <a href="#a657048a5d7f39201f785d121a385c1fb">More...</a><br /></td></tr>
<tr class="separator:a657048a5d7f39201f785d121a385c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba292560800158a5631f439aac326fd"><td class="memItemLeft" align="right" valign="top">boost::array&lt; boost::multi_array&lt; double, 1 &gt;::index, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#abba292560800158a5631f439aac326fd">getMultiArrayIndexArray</a> (const boost::multi_array&lt; double, 1 &gt; &amp;multiArray, const double *requestedElement)</td></tr>
<tr class="memdesc:abba292560800158a5631f439aac326fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of pointer to single entry in multi-array (size 1) of doubles.  <a href="#abba292560800158a5631f439aac326fd">More...</a><br /></td></tr>
<tr class="separator:abba292560800158a5631f439aac326fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52273ae41a9cf75389b839cbad7e1bea"><td class="memItemLeft" align="right" valign="top">boost::array&lt; boost::multi_array&lt; double, 2 &gt;::index, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a52273ae41a9cf75389b839cbad7e1bea">getMultiArrayIndexArray</a> (const boost::multi_array&lt; double, 2 &gt; &amp;multiArray, const double *requestedElement)</td></tr>
<tr class="memdesc:a52273ae41a9cf75389b839cbad7e1bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of pointer to single entry in multi-array (size 2) of doubles.  <a href="#a52273ae41a9cf75389b839cbad7e1bea">More...</a><br /></td></tr>
<tr class="separator:a52273ae41a9cf75389b839cbad7e1bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c60559e4cf7a6fd604383f22ff2104"><td class="memItemLeft" align="right" valign="top">boost::array&lt; boost::multi_array&lt; double, 3 &gt;::index, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a07c60559e4cf7a6fd604383f22ff2104">getMultiArrayIndexArray</a> (const boost::multi_array&lt; double, 3 &gt; &amp;multiArray, const double *requestedElement)</td></tr>
<tr class="memdesc:a07c60559e4cf7a6fd604383f22ff2104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get indices of pointer to single entry in multi-array (size 3) of doubles.  <a href="#a07c60559e4cf7a6fd604383f22ff2104">More...</a><br /></td></tr>
<tr class="separator:a07c60559e4cf7a6fd604383f22ff2104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cdd935427a4cca8218aae7e2d6e408"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93cdd935427a4cca8218aae7e2d6e408"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a93cdd935427a4cca8218aae7e2d6e408">getSortOrderOfVector</a> (const std::vector&lt; T &gt; unsortedVector)</td></tr>
<tr class="memdesc:a93cdd935427a4cca8218aae7e2d6e408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the order in which the input vector would be sorted (in ascending order)  <a href="#a93cdd935427a4cca8218aae7e2d6e408">More...</a><br /></td></tr>
<tr class="separator:a93cdd935427a4cca8218aae7e2d6e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553717c9b01a377e5fbb47f9f3b596d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a553717c9b01a377e5fbb47f9f3b596d2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a553717c9b01a377e5fbb47f9f3b596d2">getSortOrderOfVectorAndSortedVector</a> (const std::vector&lt; T &gt; unsortedVector)</td></tr>
<tr class="memdesc:a553717c9b01a377e5fbb47f9f3b596d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get sorted vector of an input vector, as well as the order in which this input has been be sorted (ascending)  <a href="#a553717c9b01a377e5fbb47f9f3b596d2">More...</a><br /></td></tr>
<tr class="separator:a553717c9b01a377e5fbb47f9f3b596d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0afd96ccb1d157c57ba326f0bb93e4f"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:aa0afd96ccb1d157c57ba326f0bb93e4f"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; S, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#aa0afd96ccb1d157c57ba326f0bb93e4f">linearlyScaleKeyOfMap</a> (const std::map&lt; S, T &gt; &amp;originalMap, S offset, S scale, bool isOffsetAppliedFirst=true)</td></tr>
<tr class="memdesc:aa0afd96ccb1d157c57ba326f0bb93e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to recalculate map keys as a linear function of original map keys.  <a href="#aa0afd96ccb1d157c57ba326f0bb93e4f">More...</a><br /></td></tr>
<tr class="separator:aa0afd96ccb1d157c57ba326f0bb93e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a43245367b57d45bd45d227d7c66bd"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T &gt; </td></tr>
<tr class="memitem:a37a43245367b57d45bd45d227d7c66bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a37a43245367b57d45bd45d227d7c66bd">printMapContents</a> (const std::map&lt; S, T &gt; &amp;mapToPrint)</td></tr>
<tr class="memdesc:a37a43245367b57d45bd45d227d7c66bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to print the contents of a map, line by line.  <a href="#a37a43245367b57d45bd45d227d7c66bd">More...</a><br /></td></tr>
<tr class="separator:a37a43245367b57d45bd45d227d7c66bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c18680bb1f7965a1e41e364fe363149"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c18680bb1f7965a1e41e364fe363149"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a8c18680bb1f7965a1e41e364fe363149">sgn</a> (const T &amp;val)</td></tr>
<tr class="memdesc:a8c18680bb1f7965a1e41e364fe363149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return the sign (+1 or -1) of a variable of type T.  <a href="#a8c18680bb1f7965a1e41e364fe363149">More...</a><br /></td></tr>
<tr class="separator:a8c18680bb1f7965a1e41e364fe363149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94971b7f6fac5f78fe00dbdddb1e8d20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94971b7f6fac5f78fe00dbdddb1e8d20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a94971b7f6fac5f78fe00dbdddb1e8d20">sliceStlVector</a> (const std::vector&lt; T &gt; &amp;vectorToBeSliced, unsigned int startIndex=0, unsigned int endIndex=std::numeric_limits&lt; unsigned int &gt;::signaling_NaN())</td></tr>
<tr class="memdesc:a94971b7f6fac5f78fe00dbdddb1e8d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to slice standard library vector, given an optional initial and final slicing values.  <a href="#a94971b7f6fac5f78fe00dbdddb1e8d20">More...</a><br /></td></tr>
<tr class="separator:a94971b7f6fac5f78fe00dbdddb1e8d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c853341920db96eb057865033764d22"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a6c853341920db96eb057865033764d22"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a6c853341920db96eb057865033764d22">subtractFunctionReturn</a> (const std::function&lt; S() &gt; function1, const std::function&lt; S() &gt; function2)</td></tr>
<tr class="memdesc:a6c853341920db96eb057865033764d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to subtract the return values of two boost function with empty input argument list.  <a href="#a6c853341920db96eb057865033764d22">More...</a><br /></td></tr>
<tr class="separator:a6c853341920db96eb057865033764d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ee8b9e31498e72904a2d8100300cb7"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a84ee8b9e31498e72904a2d8100300cb7"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../da/de0/namespacetudat_1_1utilities.html#a84ee8b9e31498e72904a2d8100300cb7">sumFunctionReturn</a> (const std::function&lt; S() &gt; function1, const std::function&lt; S() &gt; function2)</td></tr>
<tr class="memdesc:a84ee8b9e31498e72904a2d8100300cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to sum the return values of two boost function with empty input argument list.  <a href="#a84ee8b9e31498e72904a2d8100300cb7">More...</a><br /></td></tr>
<tr class="separator:a84ee8b9e31498e72904a2d8100300cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abba292560800158a5631f439aac326fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba292560800158a5631f439aac326fd">&#9670;&nbsp;</a></span>getMultiArrayIndexArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt; boost::multi_array&lt; double, 1 &gt;::index, 1 &gt; tudat::utilities::getMultiArrayIndexArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get indices of pointer to single entry in multi-array (size 1) of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices of pointer to single entry in multi-array of doubles </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00020">20</a> of file <a class="el" href="../../de/da5/utilities_8cpp_source.html">utilities.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00406">getMultiArrayIndex()</a>, and <a class="el" href="../../dd/d94/aerodynamic_coefficient_reader_8h_source.html#l00032">tudat::input_output::mergeNDimensionalCoefficients()</a>.</p>

</div>
</div>
<a id="a52273ae41a9cf75389b839cbad7e1bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52273ae41a9cf75389b839cbad7e1bea">&#9670;&nbsp;</a></span>getMultiArrayIndexArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt; boost::multi_array&lt; double, 2 &gt;::index, 2 &gt; tudat::utilities::getMultiArrayIndexArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get indices of pointer to single entry in multi-array (size 2) of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices of pointer to single entry in multi-array of doubles </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00035">35</a> of file <a class="el" href="../../de/da5/utilities_8cpp_source.html">utilities.cpp</a>.</p>

</div>
</div>
<a id="a07c60559e4cf7a6fd604383f22ff2104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c60559e4cf7a6fd604383f22ff2104">&#9670;&nbsp;</a></span>getMultiArrayIndexArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::array&lt; boost::multi_array&lt; double, 3 &gt;::index, 3 &gt; tudat::utilities::getMultiArrayIndexArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get indices of pointer to single entry in multi-array (size 3) of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indices of pointer to single entry in multi-array of doubles </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00050">50</a> of file <a class="el" href="../../de/da5/utilities_8cpp_source.html">utilities.cpp</a>.</p>

</div>
</div>
<a id="aa0afd96ccb1d157c57ba326f0bb93e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0afd96ccb1d157c57ba326f0bb93e4f">&#9670;&nbsp;</a></span>linearlyScaleKeyOfMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; S, T &gt; tudat::utilities::linearlyScaleKeyOfMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; S, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOffsetAppliedFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to recalculate map keys as a linear function of original map keys, i.e. new map key is constant * old key - offset or ( old key - offset ) * constant, where the choise between these two is provided by an input boolean. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalMap</td><td>Orignal, unscaled map </td></tr>
    <tr><td class="paramname">offset</td><td>Offset that is to be applied to (subtracted from) map keys </td></tr>
    <tr><td class="paramname">scale</td><td>Value by which existing map keys are to be scaled (either before or agter application of offset variabled, depending on value of isOffsetAppliedFirst input variable) </td></tr>
    <tr><td class="paramname">isOffsetAppliedFirst</td><td>Boolean denoting order in which offset and scale are to be applied to existing map keys. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00041">41</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ab7ffa5bbb8bf510a4e3942a82e36d63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ffa5bbb8bf510a4e3942a82e36d63c">&#9670;&nbsp;</a></span>createVectorFromMapValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; VectorArgument &gt; tudat::utilities::createVectorFromMapValues </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the values of a map. The output vector is in the order of the map entries, i.e. as provided by a forward iterator. The map keys are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original map from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the map values </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00075">75</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00208">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>, and <a class="el" href="../../d3/db7/multi_arc_ephemeris_8h_source.html#l00144">tudat::ephemerides::MultiArcEphemeris::resetSingleArcEphemerides()</a>.</p>

</div>
</div>
<a id="a7ff6b03086e9d46b54a9a9b0147e3126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff6b03086e9d46b54a9a9b0147e3126">&#9670;&nbsp;</a></span>createVectorFromMapKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KeyType &gt; tudat::utilities::createVectorFromMapKeys </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the keys of a map. The output vector is in the order of the map entries, i.e. as provided by a forward iterator. The map values are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original map from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the map keys </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00100">100</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/de7/create_observation_partials_8h_source.html#l00277">tudat::observation_partials::ObservationPartialCreator&lt; 1, ObservationScalarType, TimeType &gt;::createObservationPartials()</a>, <a class="el" href="../../df/de7/create_observation_partials_8h_source.html#l00348">tudat::observation_partials::ObservationPartialCreator&lt; 2, ObservationScalarType, TimeType &gt;::createObservationPartials()</a>, <a class="el" href="../../df/de7/create_observation_partials_8h_source.html#l00400">tudat::observation_partials::ObservationPartialCreator&lt; 3, ObservationScalarType, TimeType &gt;::createObservationPartials()</a>, <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00208">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>, <a class="el" href="../../d3/db7/multi_arc_ephemeris_8h_source.html#l00144">tudat::ephemerides::MultiArcEphemeris::resetSingleArcEphemerides()</a>, <a class="el" href="../../d1/de5/aerodynamic_coefficient_generator_8h_source.html#l00180">tudat::aerodynamics::AerodynamicCoefficientGenerator&lt; 3, 6 &gt;::saveAerodynamicCoefficientsTables()</a>, <a class="el" href="../../dd/d82/aerodynamic_coefficient_interface_8h_source.html#l00299">tudat::aerodynamics::AerodynamicCoefficientInterface::setControlSurfaceIncrements()</a>, <a class="el" href="../../d5/dd7/variational_equations_solver_8h_source.html#l00952">tudat::propagators::setPropagatorSettingsMultiArcStatesInEstimatedDynamicalParameters()</a>, and <a class="el" href="../../d0/dc9/observation_simulator_8h_source.html#l00075">tudat::observation_models::simulateObservationsWithCheck()</a>.</p>

</div>
</div>
<a id="a84ee8b9e31498e72904a2d8100300cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ee8b9e31498e72904a2d8100300cb7">&#9670;&nbsp;</a></span>sumFunctionReturn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S tudat::utilities::sumFunctionReturn </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to sum the return values of two boost function with empty input argument list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function1</td><td>First function to be added. </td></tr>
    <tr><td class="paramname">function2</td><td>Second function to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of return values of function1 and function2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00125">125</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a6c853341920db96eb057865033764d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c853341920db96eb057865033764d22">&#9670;&nbsp;</a></span>subtractFunctionReturn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S tudat::utilities::subtractFunctionReturn </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; S() &gt;&#160;</td>
          <td class="paramname"><em>function2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to subtract the return values of two boost function with empty input argument list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function1</td><td>First function to be subtracted from. </td></tr>
    <tr><td class="paramname">function2</td><td>Second function to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return values of function1 - return value of function2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00138">138</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a03307b67bd8ee0129a64107e1014a78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03307b67bd8ee0129a64107e1014a78a">&#9670;&nbsp;</a></span>createVectorBlockMatrixHistory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::createVectorBlockMatrixHistory </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrixHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; S, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>blockMatrixHistory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; int, int &gt;&#160;</td>
          <td class="paramname"><em>startIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>segmentSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector matrix block history from full matrix history. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrixHistory</td><td>Full matrix history </td></tr>
    <tr><td class="paramname">blockMatrixHistory</td><td>Block vector history (return by reference). </td></tr>
    <tr><td class="paramname">startIndices</td><td>Starting point (row,column) in matrix of return vector blocks. </td></tr>
    <tr><td class="paramname">segmentSize</td><td>Number of rows in vector. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00152">152</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/dd7/variational_equations_solver_8h_source.html#l00718">tudat::propagators::SingleArcVariationalEquationsSolver&lt; StateScalarType, TimeType &gt;::integrateVariationalAndDynamicalEquations()</a>, and <a class="el" href="../../d5/dd7/variational_equations_solver_8h_source.html#l01215">tudat::propagators::MultiArcVariationalEquationsSolver&lt; StateScalarType, TimeType &gt;::integrateVariationalAndDynamicalEquations()</a>.</p>

</div>
</div>
<a id="a37a43245367b57d45bd45d227d7c66bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a43245367b57d45bd45d227d7c66bd">&#9670;&nbsp;</a></span>printMapContents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::printMapContents </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; S, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapToPrint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to print the contents of a map, line by line. Both the key and value types must have the &lt;&lt; operator defined </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapToPrint</td><td>Map that is to be printed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00175">175</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d8/d7e/dynamics_simulator_8h_source.html#l00392">tudat::propagators::SingleArcDynamicsSimulator&lt; StateScalarType, TimeType &gt;::SingleArcDynamicsSimulator()</a>.</p>

</div>
</div>
<a id="a0f97484a4f7f2e8ecf91f4fd8c7c7cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f97484a4f7f2e8ecf91f4fd8c7c7cc2">&#9670;&nbsp;</a></span>castMatrixMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename U , typename V , int Rows, int Columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::castMatrixMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; S, Eigen::Matrix&lt; T, Rows, Columns &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; U, Eigen::Matrix&lt; V, Rows, Columns &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>newTypesMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to produce a map of <a class="el" href="../../d0/da5/namespace_eigen.html">Eigen</a> matrices, cast from one set of key/matrix scalar type set to another set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalMap</td><td>Map in original types </td></tr>
    <tr><td class="paramname">newTypesMap</td><td>Map that is to be created (returned by reference). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00191">191</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ac7db522751f00da8b6f97f01a03fda73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7db522751f00da8b6f97f01a03fda73">&#9670;&nbsp;</a></span>dynamicCastSVectorToTVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::shared_ptr&lt; T &gt; &gt; tudat::utilities::dynamicCastSVectorToTVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; S &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to dynamic cast vector of shared pointers of one type (S) to shared pointers of another type (T). The dynamic cast must be permissible, i.e. an S pointer must succesfully dynamic cast to a T pointer (T shoudl typically derive from S). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalVector</td><td>Vector of S shared pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dynamic casted vector of T shared pointers. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00210">210</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../db/dec/create_acceleration_partials_8cpp_source.html#l00022">tudat::simulation_setup::createTidalLoveNumberInterfaces()</a>.</p>

</div>
</div>
<a id="a8826e25d6f4baf3d1034c2b8237d0c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8826e25d6f4baf3d1034c2b8237d0c5d">&#9670;&nbsp;</a></span>createConcatenatedEigenMatrixFromMapValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ScalarType , int NumberOfRows, int NumberOfColumns = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, NumberOfColumns &gt; tudat::utilities::createConcatenatedEigenMatrixFromMapValues </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, NumberOfRows, NumberOfColumns &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00225">225</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d06/observation_manager_8h_source.html#l00228">tudat::observation_models::ObservationManager&lt; ObservationSize, ObservationScalarType, TimeType &gt;::computeObservationsWithPartials()</a>, <a class="el" href="../../d9/d05/unscented_kalman_filter_8h_source.html#l00204">tudat::filters::UnscentedKalmanFilter&lt; IndependentVariableType, DependentVariableType &gt;::getHistoryOfSigmaPoints()</a>, and <a class="el" href="../../d0/dc9/observation_simulator_8h_source.html#l00075">tudat::observation_models::simulateObservationsWithCheck()</a>.</p>

</div>
</div>
<a id="ab937fe377fe527b8f2f66772c882130f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab937fe377fe527b8f2f66772c882130f">&#9670;&nbsp;</a></span>extractKeyAndValuesFromMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ScalarType , int NumberOfRows&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, 1 &gt;, Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; tudat::utilities::extractKeyAndValuesFromMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, NumberOfRows, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00282">282</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ae084b530a39126d9f71b9564a1795c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae084b530a39126d9f71b9564a1795c4a">&#9670;&nbsp;</a></span>convertEigenVectorToStlVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; tudat::utilities::convertEigenVectorToStlVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00312">312</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00208">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>, <a class="el" href="../../d3/de0/radiation_pressure_coefficient_8h_source.html#l00144">tudat::estimatable_parameters::ArcWiseRadiationPressureCoefficient::setParameterValue()</a>, and <a class="el" href="../../de/d17/constant_drag_coefficient_8h_source.html#l00152">tudat::estimatable_parameters::ArcWiseConstantDragCoefficient::setParameterValue()</a>.</p>

</div>
</div>
<a id="a6185604e1e88e807107fba0d5fcd0b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6185604e1e88e807107fba0d5fcd0b81">&#9670;&nbsp;</a></span>convertStlVectorToEigenVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; tudat::utilities::convertStlVectorToEigenVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>stlVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00325">325</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dc/d42/pod_processing_8h_source.html#l00390">tudat::simulation_setup::calculateCovarianceUsingDataUpToEpoch()</a>, <a class="el" href="../../df/dd6/propagation_patched_conic_full_problem_8cpp_source.html#l00220">tudat::propagators::createTransferTrajectoryObject()</a>, <a class="el" href="../../d3/dea/least_squares_estimation_8cpp_source.html#l00208">tudat::linear_algebra::getLeastSquaresPolynomialFit()</a>, <a class="el" href="../../db/d6d/periodic_spin_variation_8h_source.html#l00063">tudat::estimatable_parameters::PeriodicSpinVariation::getParameterValue()</a>, <a class="el" href="../../d5/d21/polar_motion_amplitude_8h_source.html#l00065">tudat::estimatable_parameters::PolarMotionAmplitude::getParameterValue()</a>, <a class="el" href="../../d3/de0/radiation_pressure_coefficient_8h_source.html#l00134">tudat::estimatable_parameters::ArcWiseRadiationPressureCoefficient::getParameterValue()</a>, and <a class="el" href="../../de/d17/constant_drag_coefficient_8h_source.html#l00142">tudat::estimatable_parameters::ArcWiseConstantDragCoefficient::getParameterValue()</a>.</p>

</div>
</div>
<a id="a38a390209923d63884b1e5af56554cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a390209923d63884b1e5af56554cd1">&#9670;&nbsp;</a></span>convertStlVectorToEigenMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Rows = Eigen::Dynamic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; tudat::utilities::convertStlVectorToEigenMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Matrix&lt; T, Rows, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>stlVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00337">337</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="af54bd13dd445f57624d887406b2a3f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54bd13dd445f57624d887406b2a3f3c">&#9670;&nbsp;</a></span>addScalarToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; tudat::utilities::addScalarToVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to add a double to all entries in an STL vector (addition of a double must be defined for T type). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>Vector to which a double is to be added. </td></tr>
    <tr><td class="paramname">scalar</td><td>Value that is to be added to vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector with scalar added to all entries of input vector. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00365">365</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../dd/de9/orbit_determination_test_cases_8h_source.html#l00045">tudat::unit_tests::executePlanetaryParameterEstimation()</a>.</p>

</div>
</div>
<a id="a76098cf72d99535ce14d506f507c2ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76098cf72d99535ce14d506f507c2ed5">&#9670;&nbsp;</a></span>copyMultiArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , int NumberOfDimensions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::copyMultiArray </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrayToCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; S, NumberOfDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to copy a multi-array into another multi-array, resizing the new multi-array accordingly </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arrayToCopy</td><td>Multi-array that is to be copied </td></tr>
    <tr><td class="paramname">targetArray</td><td>New multi-array into which arrayToCopy is to be copied (returned by reference). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00387">387</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a657048a5d7f39201f785d121a385c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657048a5d7f39201f785d121a385c1fb">&#9670;&nbsp;</a></span>getMultiArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int NumberOfDimensions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::multi_array&lt; double, NumberOfDimensions &gt;::index tudat::utilities::getMultiArrayIndex </td>
          <td>(</td>
          <td class="paramtype">const typename boost::multi_array&lt; double, NumberOfDimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>requestedElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get index in nth direction of pointer to single entry in multi-array of doubles </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiArray</td><td>Multi-array for which the index is to be retrieved </td></tr>
    <tr><td class="paramname">requestedElement</td><td>Pointer to element for which index is to be retrieved </td></tr>
    <tr><td class="paramname">direction</td><td>Dimension of multi-array for which index is to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in nth direction of pointer to single entry in multi-array of doubles </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00406">406</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">References <a class="el" href="../../de/da5/utilities_8cpp_source.html#l00020">getMultiArrayIndexArray()</a>.</p>

</div>
</div>
<a id="a855f3e9a1ac6f189ecb64eca19bc1c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855f3e9a1ac6f189ecb64eca19bc1c76">&#9670;&nbsp;</a></span>createVectorFromVectorOfPairFirsts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; S &gt; tudat::utilities::createVectorFromVectorOfPairFirsts </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; S, T &gt; &gt;&#160;</td>
          <td class="paramname"><em>inputVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00446">446</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="afb6d1809b5ffd015d531e456b61172e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6d1809b5ffd015d531e456b61172e0">&#9670;&nbsp;</a></span>evaluateFunctionWithoutInputArgumentDependency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tudat::utilities::evaluateFunctionWithoutInputArgumentDependency </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; T() &gt;&#160;</td>
          <td class="paramname"><em>inputFreeFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>dummyInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00458">458</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a93cdd935427a4cca8218aae7e2d6e408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cdd935427a4cca8218aae7e2d6e408">&#9670;&nbsp;</a></span>getSortOrderOfVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; tudat::utilities::getSortOrderOfVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>unsortedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to get the order in which the input vector would be sorted (in ascending order). Example: for inout vector (5,2,6,7,4,0), output would be (5,1,4,0,2,3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unsortedVector</td><td>Vector of which the sort order is to be determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Order in which the input vector would be sorted (in ascending order) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00471">471</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00536">getSortOrderOfVectorAndSortedVector()</a>.</p>

</div>
</div>
<a id="ae625adfdbd740bfdf4c5843bd0c4e414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae625adfdbd740bfdf4c5843bd0c4e414">&#9670;&nbsp;</a></span>createVectorFromMultiMapValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; VectorArgument &gt; tudat::utilities::createVectorFromMultiMapValues </td>
          <td>(</td>
          <td class="paramtype">const std::multimap&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the values of a multimap. The output vector is in the order of the multimap entries, i.e. as provided by a forward iterator. The multimap keys are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original multimap from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the multimap values </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00484">484</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00536">getSortOrderOfVectorAndSortedVector()</a>.</p>

</div>
</div>
<a id="a296cc0b23594eca7a78a8500ee568af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296cc0b23594eca7a78a8500ee568af6">&#9670;&nbsp;</a></span>createVectorFromMultiMapKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorArgument , typename KeyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; KeyType &gt; tudat::utilities::createVectorFromMultiMapKeys </td>
          <td>(</td>
          <td class="paramtype">const std::multimap&lt; KeyType, VectorArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to create a vector from the keys of a multimap. The output vector is in the order of the multimap entries, i.e. as provided by a forward iterator. The multimap values are not used for the return vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>Original multimap from which the vector is to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector created from the multimap keys </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00510">510</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00536">getSortOrderOfVectorAndSortedVector()</a>.</p>

</div>
</div>
<a id="a553717c9b01a377e5fbb47f9f3b596d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553717c9b01a377e5fbb47f9f3b596d2">&#9670;&nbsp;</a></span>getSortOrderOfVectorAndSortedVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; int &gt;, std::vector&lt; T &gt; &gt; tudat::utilities::getSortOrderOfVectorAndSortedVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>unsortedVector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to get sorted vector of an input vector, as well as the order in which this input has been be sorted (ascending)). Example: for inout vector (5,2,6,7,4,0), output would be [(5,1,4,0,2,3), (0,2,4,5,6,7)]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unsortedVector</td><td>Vector that is to be sorted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parit, with first: order in which the input vector is sorted (in ascending order), second: sorted input vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00536">536</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00510">createVectorFromMultiMapKeys()</a>, and <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00484">createVectorFromMultiMapValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00471">getSortOrderOfVector()</a>, and <a class="el" href="../../dc/d42/pod_processing_8h_source.html#l00222">tudat::simulation_setup::getTimeOrderedInformationMatrix()</a>.</p>

</div>
</div>
<a id="a3c3729d39dbee0d760df4a34697f77d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3729d39dbee0d760df4a34697f77d5">&#9670;&nbsp;</a></span>doStlVectorContentsMatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool tudat::utilities::doStlVectorContentsMatch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectorA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectorB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00548">548</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/db0/gravity_field_variations_8cpp_source.html#l00272">tudat::gravitation::GravityFieldVariationsSet::getDirectTidalGravityFieldVariation()</a>.</p>

</div>
</div>
<a id="a19f2c25526670ce13bcf9468760cfffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f2c25526670ce13bcf9468760cfffd">&#9670;&nbsp;</a></span>convertStlVectorMapToEigenVectorMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapKey , typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; MapKey, Eigen::Array&lt; ScalarType, Eigen::Dynamic, 1 &gt; &gt; tudat::utilities::convertStlVectorMapToEigenVectorMap </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; MapKey, std::vector&lt; ScalarType &gt; &gt;&#160;</td>
          <td class="paramname"><em>stlVectorMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00573">573</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a94971b7f6fac5f78fe00dbdddb1e8d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94971b7f6fac5f78fe00dbdddb1e8d20">&#9670;&nbsp;</a></span>sliceStlVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; tudat::utilities::sliceStlVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectorToBeSliced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>endIndex</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::signaling_NaN(&#160;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00591">591</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a8f2166e0c5c4b43b40aabee7237d4a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2166e0c5c4b43b40aabee7237d4a28">&#9670;&nbsp;</a></span>castDynamicToFixedSizeEigenVectorMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ScalarType , int FixedSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tudat::utilities::castDynamicToFixedSizeEigenVectorMap </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, Eigen::Dynamic, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; KeyType, Eigen::Matrix&lt; ScalarType, FixedSize, 1 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fixedSizeMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00625">625</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a8c18680bb1f7965a1e41e364fe363149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c18680bb1f7965a1e41e364fe363149">&#9670;&nbsp;</a></span>sgn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int tudat::utilities::sgn </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Variable for which sign is to be determined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sign of variable </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html#l00640">640</a> of file <a class="el" href="../../d2/d81/_basics_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 6 2020 13:50:46 for Tudat by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
